#include <ranges>

// This is an automatically generated file.
// A sparse LDPC matrix (containing only zeros and ones) is saved in compressed sparse column (CSC) format.
// Since the matrix (and LDPC code) is known at compile time, there is no need to save it separately in a file.
// This significantly blows up the executable size (the memory would still have to be used when saving the matrix).
// The method seems to be reasonably fast (on a standard laptop).

#include <algorithm>
#include <cstdint>
#include <array>
#include <span>
#include <iostream>
#include <random>
#include <vector>

template<typename T, std::size_t N>
void noise_bitstring_inplace(std::array<T, N> &src, double err_prob, unsigned int seed = 0) {
    std::mt19937_64 rng{seed}; // hard-coded seed for testing purposes.

    std::bernoulli_distribution distribution(err_prob);

    for (std::size_t i = 0; i < src.size(); i++) {
        if (distribution(rng)) {
            src[i] = !src[i];
        } else {
            src[i] = src[i];
        }
    }
}

/// this checks that the QC-encoder will never access input or output arrays outside bounds.
/// I.e., for the input the size is `expansion_factor*N` while output size is `expansion_factor*M`.
template <std::size_t M, std::size_t N, std::size_t num_nz,
        typename t_colptr, typename t_rowidx, typename t_val>
constexpr bool matrix_consistent_with_input_size(
        const std::array<t_colptr, N + 1> &colptr,
        const std::array<t_rowidx, num_nz> &row_idx,
        const std::array<t_val, num_nz> &values,
        const std::size_t expansion_factor
) {

    for (std::size_t col = 0; col < M; col++) {
        auto effCol = col/expansion_factor;
        for (std::size_t j = colptr[effCol]; j < colptr[effCol + 1]; j++) {
            auto shiftVal = values[j];
            auto outIdx = expansion_factor*row_idx[j] + col%expansion_factor;
            auto inIdx = (col + shiftVal) % expansion_factor;
            if (outIdx >= M*expansion_factor || inIdx >= N*expansion_factor) {
                return false;
            }
        }
    }

    return true;
}

namespace AutogenLDPC_QC {

    constexpr inline std::size_t M = 64;
    constexpr inline std::size_t N = 128;
    constexpr inline std::size_t num_nz = 480;
    constexpr inline std::size_t expansion_factor = 32;

    constexpr inline std::array<std::uint16_t, N + 1> colptr = {
            0x0,0x2,0x5,0xd,0xf,0x11,0x14,0x1c,0x1e,0x20,0x23,0x2b,0x2d,0x2f,0x32,0x3a,0x3c,0x3e,0x41,0x49,0x4b,0x4d,0x50,0x58,0x5a,0x5c,0x5f,0x67,0x69,0x6b,0x6e,0x76,0x78,0x7a,0x7d,0x85,0x87,0x89,0x8c,0x94,0x96,0x98,0x9b,0xa3,0xa5,0xa7,0xaa,0xb2,0xb4,0xb6,0xb9,0xc1,0xc3,0xc5,0xc8,0xd0,0xd2,0xd4,0xd7,0xdf,0xe1,0xe3,0xe6,0xee,0xf0,0xf2,0xf5,0xfd,0xff,0x101,0x104,0x10c,0x10e,0x110,0x113,0x11b,0x11d,0x11f,0x122,0x12a,0x12c,0x12e,0x131,0x139,0x13b,0x13d,0x140,0x148,0x14a,0x14c,0x14f,0x157,0x159,0x15b,0x15e,0x166,0x168,0x16a,0x16d,0x175,
            0x177,0x179,0x17c,0x184,0x186,0x188,0x18b,0x193,0x195,0x197,0x19a,0x1a2,0x1a4,0x1a6,0x1a9,0x1b1,0x1b3,0x1b5,0x1b8,0x1c0,0x1c2,0x1c4,0x1c7,0x1cf,0x1d1,0x1d3,0x1d6,0x1de,0x1e0
    };

// -------------------------------------------------------

    constexpr inline std::array<std::uint8_t, num_nz> row_idx = {
            0x17,0x1b,0xd,0x2a,0x2e,0x3,0x6,0x1e,0x2e,0x32,0x35,0x36,0x3f,0x39,0x3e,0x27,0x3d,0x22,0x27,0x3c,0x5,0x1f,0x24,0x25,0x2a,0x2c,0x2e,0x36,0x1d,0x30,0xd,0x1d,0xa,0x20,0x39,0x4,0x8,0x11,0x17,0x1a,0x32,0x37,0x38,0xd,0x14,0xb,0x35,0x1f,0x38,0x3e,0x0,0x1,0xa,0x10,0x1b,0x1e,0x1f,0x32,0x0,0x29,0x1b,0x2f,0x7,0x24,0x3a,0xb,0x14,0x1e,0x21,0x22,0x36,0x3a,0x3b,0x23,0x3a,0x5,0x15,0x16,0x2c,0x3f,0x5,0x9,0xc,0x12,0x19,0x1c,0x28,0x3c,0x22,0x3b,0x25,0x33,0xc,0x26,0x3d,0x1,0x3,0xa,0x10,0x18,
            0x1d,0x20,0x24,0x10,0x2b,0xf,0x1f,0x0,0x18,0x2f,0x0,0xf,0x13,0x18,0x23,0x28,0x30,0x3e,0x9,0x20,0xb,0x3f,0x26,0x2e,0x33,0x8,0xd,0xe,0x16,0x1a,0x23,0x30,0x3d,0xe,0x13,0x7,0x31,0x1a,0x1c,0x2d,0x2,0x8,0x11,0x16,0x21,0x31,0x34,0x38,0xa,0x11,0x23,0x2d,0x1,0x1a,0x2a,0xc,0x17,0x20,0x2c,0x2d,0x30,0x37,0x3c,0x17,0x2a,0x7,0x31,0x13,0x18,0x22,0x2,0x5,0xa,0xc,0x24,0x28,0x33,0x35,0x1a,0x3f,0x9,0xf,0x2,0x12,0x15,0x0,0x3,0x6,0xa,0x25,0x2e,0x3a,0x3f,0x1,0x6,0x15,0x23,0x12,0x1b,0x28,
            0xe,0xf,0x12,0x14,0x1a,0x27,0x32,0x37,0x16,0x1b,0x2b,0x39,0x1e,0x2c,0x31,0x4,0x16,0x18,0x1a,0x21,0x2b,0x2c,0x2d,0x8,0x3d,0x13,0x21,0xe,0x11,0x30,0x9,0xc,0x18,0x19,0x1a,0x22,0x23,0x2c,0x5,0x2e,0x17,0x3d,0x10,0x24,0x29,0x6,0xe,0x1d,0x22,0x29,0x2b,0x3a,0x3e,0x18,0x37,0x1d,0x39,0x2,0xb,0x36,0x4,0x6,0x15,0x18,0x2a,0x38,0x3b,0x3d,0x33,0x3c,0x21,0x2f,0x3,0x10,0x30,0x4,0xc,0x10,0x1f,0x20,0x2f,0x38,0x3d,0x32,0x35,0x1f,0x29,0x6,0x1e,0x37,0x7,0xa,0xb,0x22,0x27,0x2a,0x30,0x3a,0xc,0x2f,
            0x19,0x27,0x8,0x3b,0x3c,0x4,0x12,0x15,0x28,0x29,0x2d,0x34,0x3c,0x2,0x3,0x19,0x3f,0x4,0x2b,0x3e,0x7,0x1c,0x24,0x25,0x26,0x2e,0x2f,0x34,0x31,0x36,0x5,0x2b,0xc,0xf,0x28,0x15,0x16,0x17,0x1e,0x26,0x2a,0x3b,0x3c,0x15,0x1e,0x1,0x3b,0x0,0x17,0x1c,0x2,0x10,0x1b,0x1e,0x26,0x39,0x3a,0x3f,0x7,0x28,0x3,0x9,0x23,0x34,0x36,0x1,0x2,0x7,0xe,0x11,0x14,0x26,0x3e,0xb,0x24,0x11,0x29,0x14,0x20,0x25,0x2,0xb,0xd,0x20,0x24,0x32,0x34,0x35,0xf,0x12,0x3,0xd,0x4,0x16,0x35,0x6,0x12,0x13,0x14,0x19,
            0x2b,0x36,0x3e,0x19,0x38,0x1,0x3b,0x5,0x6,0x8,0x8,0x1b,0x1c,0x2a,0x2f,0x30,0x38,0x39,0x1f,0x34,0x25,0x2d,0xa,0x21,0x32,0x0,0x9,0xf,0x10,0x13,0x34,0x36,0x3e,0x21,0x26,0x13,0x37,0xe,0x19,0x38,0x0,0xd,0x16,0x1c,0x1d,0x26,0x2e,0x31,0x1c,0x2d,0x33,0x35,0x9,0x14,0x3a,0x14,0x1c,0x22,0x27,0x28,0x31,0x33,0x3c,0x4,0x27,0x11,0x37,0x1d,0x32,0x34,0x8,0xe,0x12,0x20,0x29,0x2c,0x33,0x39,0x25,0x2c
    };


// -------------------------------------------------------

    constexpr inline std::array<std::uint8_t, num_nz> values = {
            29,27,7,20,9,26,29,11,9,32,32,20,9,31,17,11,8,24,6,6,22,26,5,26,15,12,10,8,15,23,5,18,14,25,15,3,32,22,2,11,3,22,2,16,4,27,2,6,29,2,10,27,6,1,17,26,13,27,7,25,5,4,11,14,16,31,19,30,19,8,4,25,4,11,11,26,21,30,10,26,3,16,26,22,20,7,25,17,10,14,23,29,1,21,7,25,29,10,26,15,
            5,28,18,14,15,20,14,28,19,24,20,2,1,7,16,21,4,30,22,11,26,26,11,19,27,17,31,3,30,2,21,17,1,19,28,21,26,27,25,26,8,12,15,16,17,12,11,30,24,10,26,4,32,10,5,7,31,5,25,8,3,23,25,32,31,11,11,11,23,21,6,23,16,17,13,21,12,10,25,15,17,31,25,30,30,18,29,3,20,26,3,7,22,18,27,4,6,17,5,16,
            13,8,20,5,25,18,8,16,29,10,12,1,27,20,13,15,4,26,24,7,11,4,4,13,11,30,23,5,10,23,7,26,32,6,20,22,2,18,29,25,4,6,14,26,17,16,1,23,3,8,19,2,26,1,25,14,6,21,32,9,19,27,26,24,14,20,18,23,8,12,11,5,30,17,28,23,17,8,5,7,14,17,14,31,22,22,1,14,9,31,29,3,21,5,15,30,29,10,8,29,
            10,23,15,28,31,13,18,14,22,15,21,26,3,25,9,27,21,9,12,28,30,31,31,27,4,6,1,22,29,16,19,22,10,31,19,31,29,18,23,27,26,10,22,23,23,14,29,7,31,29,18,15,29,27,6,1,2,23,21,4,21,4,15,6,30,24,2,32,1,1,23,5,23,24,17,6,29,22,27,19,25,21,6,10,4,9,16,5,15,28,25,1,29,3,21,21,28,29,18,6,
            23,10,29,24,5,3,25,26,25,22,20,16,16,11,23,29,19,26,27,24,5,18,19,30,11,10,21,32,4,22,15,30,5,1,4,20,17,27,4,23,23,9,15,20,28,22,19,27,13,15,24,1,14,26,25,13,28,8,12,17,12,1,8,24,19,5,10,10,27,5,23,19,17,22,28,23,10,31,10,7
    };

    static_assert(matrix_consistent_with_input_size<M, N>(
            colptr,
            row_idx,
            values,
            expansion_factor
    ), "The arrays do not imply a valid quasi-cyclic LDPC code.");
} // namespace AutogenLDPC_QC

template <
        typename bit_type, /// e.g. bool, or std::uint8_t
        std::size_t output_size, std::size_t input_size>
struct Encoder {
    static constexpr std::size_t outputSize = output_size;
    static constexpr std::size_t inputSize = input_size;

    /// performant but no size check (user has to provide valid std::span)
    /// key shall not be changed! (TODO enforce somehow...)
    /// also: inputs/outputs have to be contiguous in memory.
    virtual void encode_span(
            std::span<bit_type const, input_size> key,
            std::span<bit_type, output_size> syndrome) const = 0;

    /// general, with runtime size check
    /// (a runtime cost usually not worth worrying about)
    void encode(auto const& key, auto &syndrome) const {
        if (key.size() == inputSize && syndrome.size() == output_size) {
            encode_span(
                    std::span<bit_type const, input_size>{key},
                    std::span<bit_type, output_size>{syndrome});
        } else {
            throw std::runtime_error("LDPC encoder: incorrect sizes of intput / output arrays");
        }
    }
};


namespace {

    template<typename Bit1, typename Bit2>
    constexpr bool xor_as_bools(Bit1 lhs, Bit2 rhs) {
        return (static_cast<bool>(lhs) != static_cast<bool>(rhs));
    }

    template <
            typename bit_type, /// e.g. bool, or std::uint8_t
            std::size_t M, std::size_t N, std::size_t expansion_factor, std::size_t num_nz>
    struct EncoderQC : public Encoder<bit_type, M*expansion_factor, N*expansion_factor> {
        constexpr EncoderQC(std::array<std::uint16_t, N + 1> colptr,
                            std::array<std::uint8_t, num_nz> row_idx,
                            std::array<std::uint8_t, num_nz> values) :
                colptr(colptr), row_idx(row_idx), values(values) {}

        void encode_span(
                std::span<bit_type const, N*expansion_factor> key,
                std::span<bit_type, M*expansion_factor> syndrome) const override  {
            encode_qc(key, syndrome);
        }

        // void encode(
        //         RandomAccessIterator<bit_type, EncoderQC::inputSize> key,
        //         RandomAccessIterator<bit_type, EncoderQC::outputSize> syndrome) override {
        //         encode_qc(key, syndrome);
        // }

    private:
        void encode_qc(
                std::span<bit_type const, N*expansion_factor> in,
                std::span<bit_type, M*expansion_factor> out) const {

            static_assert(N >= M, "The syndrome should be shorter than the input bitstring.");

            for (std::size_t col = 0; col < in.size(); col++) {
                auto effCol = col/expansion_factor;
                for (std::size_t j = colptr[effCol]; j < colptr[effCol + 1]; j++) {
                    auto shiftVal = values[j];
                    auto outIdx = expansion_factor*row_idx[j] + col%expansion_factor;
                    auto inIdx = (col + shiftVal) % expansion_factor;
                    out[outIdx] = xor_as_bools(out[outIdx], in[inIdx]);
                }
            }
        }

        std::array<std::uint16_t, N + 1> colptr;
        std::array<std::uint8_t, num_nz> row_idx;
        std::array<std::uint8_t, num_nz> values;
    };
}

using namespace AutogenLDPC_QC;
constexpr EncoderQC<std::uint8_t, M, N, expansion_factor, num_nz>
        encoder1{
        AutogenLDPC_QC::colptr, AutogenLDPC_QC::row_idx, AutogenLDPC_QC::values};

int main(int argc, char** argv) {
    std::cout << "hello\n";
    std::array<std::uint8_t, AutogenLDPC_QC::N*AutogenLDPC_QC::expansion_factor> key{};
    noise_bitstring_inplace(key, 0.5, argc);

    using namespace AutogenLDPC_QC;
    std::array<std::uint8_t, M*expansion_factor> result{};

     encoder1.encode_span(std::span<std::uint8_t, 4096>{key}, std::span{result});

//    encoder1.encode(key, result);
    std::cout << result.size() << std::endl;
    for (auto v : result) {
        std::cout << (int)v << ' ';
    }
    std::cout << std::endl;
    std::cout << "hello\n";
}
